# 逻辑基础

逻辑，作为一切推理的基础，对于做出正确决断起着至关重要的作用。计算机要产生正确的运算结果，必须依赖于正确的逻辑决策。从另一个角度来说，逻辑还扮演了“时间”的角色，事件A导致了事件B，则意味着事件B的发生在于事件A的发生之后。一个清晰正确的逻辑是推动计算机逐步演算最终得到正确结果的根本动力。或者，我们可以将计算机定义为，能够根据逻辑进行相应操作的机器。

那么，什么是逻辑？逻辑如何演绎推理？为什么逻辑能够驱动计算机的运行？

## 命题逻辑

我们说，一切的结果都是有原因的，或者说，所有的*结论*都是有*前提*的。或者原因的原因也是结果的原因（我打伞因为别人都打伞，别人都打伞因为天下雨了，天下雨了也是我打伞的原因），抑或结果本身就是结果的原因（这是把椅子因为这是把椅子）。我们把前提和结论称为*命题*，一般用字母$$p, q, r, \ldots$$表示。如果把所有不必要的结论去掉，仅留下结论即是前提的结论，便构成了所有逻辑推理的基础，我们称之为*原子命题*。并且，我们赋予这些原子命题一个属性，称作*真*。

为了还原之前省略的结论，或者表达出更多的结论，我们需要定义一些*逻辑连接词*，构成*非原子命题*。根据构成新命题所需要命题的个数，我们列出一些常见逻辑连接词。

### 逻辑连接词

#### 零元连接词

零元连接词有两个，⊤表示真，⊥表示假。可以表达恒真或恒假的命题。在Julia中可用```true```和```false```分别表示。

#### 一元连接词

一元连接词有一个，称作逻辑非，表示一个命题的否定，写作¬p。在Julia中表示为```!p```。我们定义，命题p为假当且仅当其否命题¬p为真。

特别注意，一个命题并非非假即真。例如p(x)定义为"x为偶数"，那么命题p(x)的真假与变量x有关。

#### 二元连接词

两个命题p,q的合取（逻辑与）p∧q为真当且仅当p和q都为真，析取（逻辑或）p∨q为真当且仅当至少一个命题为真。需要注意，逻辑与和逻辑或与我们生活中所用的与和或概念上稍有差别。例如，生活中用“或”时，常表示二者选其一（实际为逻辑异或），而逻辑或还可以表示两者都为真。Julia中，合取和析取分别表示为```p&&q```和```p||q```。

从逻辑意义上来说，合取表示一种**极小真性**，遇假即假；析取表示一种**极大真性**，遇真即真。于是对于p∧q，若p为假，则命题为假，不必理会q；同样对于p∨q，若p为真，则命题为真，亦不必理会q。这叫合取和析取的*短路现象*。

另外一种二元连接词蕴涵，p→q为假当且仅当p为真且q为假。有的作者也将其读作“如果p，那么q”，实际上是“如果p为真，则q为真”的省略形式，不过这并没有对蕴涵做出充分解释，例如当p为假时，p→q始终为真。蕴涵在逻辑上可以理解为一种**趋真性**，也可以理解为“非p或q”。一种相似的二元连接词双向蕴涵，p↔q为真当且仅当p→q且q→p，理解为一种**等价性**。

#### 优先级

逻辑连接词其实与加减乘除无异，逻辑连接词用于对于命题进行演算，加减乘除用于对于数进行演算。故我们要注意逻辑连接词的交换性和结合性。显然，合取和析取各自都存在交换律和结合律，不过当两个连接词同时出现时，不可随意交换或结合，正如1+2×3≠1×2+3≠(1+2)×3。考虑下面这个例子：如果明天下雨或者下雪并且我没有带伞或者没穿雨靴，那么我就不去上课了。如果认为或者的优先级较高，则理解为“若(1)明天是雨雪天(2)我没有任一装备两个条件同时满足，我便不去上课了”；而倘若认为并且的优先级较高，则应理解为“只要(1)明天下雨(2)下雪且我没带伞(3)我没穿雨靴三个条件满足其一，我便不去上课了”。

为了保证表达无歧义（无”二义性“），我们规定优先级从高至低依次为：逻辑非>合取>析取>蕴涵>等价。因此，¬p||q&&r表示(¬p)||(q&&r)。所以若要优先运算逻辑或，应用括号将其括起来，例如(¬(p||q))&&r。

#### 运算律

* 交换律: $$p∧q=q∧p, p∨q=q∨p$$
* 结合律: $$(p∧q)∧r=p∧(q∧r), (p∨q)∨r=p∨(q∨r)$$
* 分配律: $$p∧(q∨r)=(p∧q)∨(p∧r)$$
* 双否律: $$¬¬p=p$$
* 对偶律(De Morgan): $$¬(p∧q)=¬p∨¬q, ¬(p∨q)=¬p∧¬q$$

#### 连接词完备性

注意到，逻辑连接词实际上就是从逻辑常数{⊤,⊥}映射到自身的函数。零元连接词是常函数，一元连接词是一元函数，二元连接词便是二元函数。现在我们考虑所有二元连接词，总共有2⁴=16种（为什么）。上述介绍的连接词可以通过延拓包含其中8种（为什么），那么，为了表达所有有效的结论，是否需要引入其余的8种连接词呢？答案是否定的。

实际上，通过连接词的复合我们可以得到其他连接词。例如，我们可以表示⊥为¬⊤，可以表示p↔q为p→q∧q→p。因此，可以找到一些连接词，使得所有其他连接词都可以由这些连接词复合得到，并且这些连接词中没有一个可以被其他连接词表示，我们称之为逻辑连接词的*极小集*。可以证明{¬,∧},{→,¬},{∨,↔,⊥}都是极小集。

### 布尔代数

我们之前已经发现，逻辑运算与代数运算都有譬如结合律、交换律、结合律的性质。那么，是否存在一种对应，包括逻辑常数与自然数的对应，逻辑连接词与算术运算符的对应，使得，我们所做的逻辑运算就是代数运算呢？

从范畴论的角度来看，我们称这种对应为*自然变换*。我们其实已经接触过许多自然变换，譬如，我们将手指与0-10的数字对应起来，使得我们可以不需要用手指也能进行十以内的计算；又如，英汉词典将中文和英文对应起来，使得我们不论用什么语言，都能传达相同的意思。如果以一种哲学视野来看，任何人类发明的符号，不论是文字还是数字，都是为了表达某种实质。不同的时代，不同的地域，不同的文明，都会创造不同的专属的符号，但是，不同的符号终究在传递共通的概念和思想。自然变换本质上就是符号的变换，就是本质的对应。

布尔代数便是这样一种对应，它是由George Boole在1847年引进的，具体规则如下：

* 逻辑常数: $$0=⊥， 1=⊤$$
* 命题: $$x,y,z,\ldots$$
* 逻辑连接词: $$¬x=1-x, x∧y=x×y, x∨y=x+y-x×y$$

布尔代数通过代数变量表示命题，用代数运算表示出了最小集，因而可表所有逻辑连接词。故我们可以通过布尔代数进行逻辑运算。

反过来，我们考虑代数运算中加法在逻辑运算中的作用。因为布尔代数中只有0和1两个数，称为*二进数*，故加法可以看作模2加，即定义x⊕y=x+y (mod 2)。有趣的是，在二进数中，加和减是等价的（为什么）。从逻辑解释上看，p⊕q为真当且仅当p,q的真值不同，我们称这种逻辑连接词为异或。不难证明，{∧，⊕，⊤}也是极小集。因此，我们可以说，{1,+,×}生成了布尔代数，布尔代数描述了逻辑运算。

## 谓词逻辑

## 习题

1. 请用Julia验证以下结果。为了验证方便，可在julia中定义一些函数，如```lhs(p,q)=p||p&&q```等，然后验证```lhs(true,false)```为```true```等。
  * 幂等律: $$p∧p=p, q∨q=q$$
  * 吸收律: $$p∧(p∨q)=p, p∨(p∧q)=p$$
  * 蕴涵：$$p→q=¬p∨q$$
  * 异或：$$p⊕q=(p∨q)∧¬(p∧q)$$
  * 等价: $$p↔q=¬(p∨q)∨(p∧q)$$
2. 在计算机硬件中，逻辑运算是通过半导体构建逻辑门实现的。我们暂且用开关和电珠代替半导体分别表示简单命题和复合命题的真假，请尝试用电池、电线、电阻、开关和电珠构造逻辑门，画出电路图。例如，与门可以用串联电路实现，这时仅当两个开关都闭合时，电珠亮。
3. 请构造加法门ADD：输入为三个比特，其中两个表示加数和被加数，另一个表示上一位进位；输出为两个比特，一个为和数的当前位，另一个为下一位进位。如ADD(1,0,1)=(0,1)，1和0为加数被加数，1为上一位进位，和为10，当前位为0，下一位进位为1。
4. 定义逻辑连接词与非p↑q=¬(p∧q)，证明{↑}是极小集。一种证明方法是，将已知极小集用↑表出。你能找出其他的极小集吗？证明你的结论。
5. 请证明{∧，⊕，⊤}是极小集，进而证明布尔代数是逻辑完备的。
6. 布尔代数保证了逻辑运算与代数运算的一致性，请用布尔代数验证运算律。
7. 实际上，布尔代数并不是唯一能实现逻辑运算的代数。1930年，Arend Heyting引入了Heyting代数，同样用1和0表示真和假，并且定义运算a⩽b当且仅当a为1且b为0，即逻辑连接词蕴涵。请证明{0,⩽}是Heyting代数的生成元，进而证明Heyting代数是逻辑完备的。



