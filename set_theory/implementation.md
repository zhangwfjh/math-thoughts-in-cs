# 程序实现

计算机中并没有集合的概念，为了赋予计算机对于集合的表达和运算能力，我们必须从基本的数据结构和程序逻辑开始将其构造出来。前面我们已经介绍了如何从数学上进行构造和运算，我们只需将集合代数的所有算子用程序实现即可。不过首先，我们需要考虑集合的数据结构，即集合在计算机中的存数方式。一般来说，集合的元素可以使用数组来存储，数组指的是内存中一块连续的空间区域，

在Julia中，一个空数组表示为`[]`，向数组`A`添加元素`x`可以使用`push!`函数。例如
```
julia> A = [];
julia> for x=1:5 push!(A,x^2) end
julia> A
5-element Array{Any,1}:
   1
   4
   9
  16
  25
```

## 集合关系的判断

为了能对集合进行运算，最基础的操作便是判断一个元素$$x$$是否在一个集合$$A$$中。这只需循环检查$$A$$中的每一个元素是否和$$x$$相等。
```
function inset(x,A)
  for a in A
    a == x && return true  # 即 if a == x return true end
  end
  return false
end
```
注意，为了判断$$x$$是否在$$A$$中，`inset`最多要做$$|A|$$次相等比较，因此我们说`inset`函数的最坏时间复杂度是$$O(|A|)$$的。

进一步，如果有集合$$A,B$$，我们可以判断集合$$A$$是否被包含在集合$$B$$中，只需检查$$A$$的每一个元素是否都在$$B$$中。
```
function subset(A,B)
  for a in A
    inset(a,B) || return false  # 即 if !inset(a,B) return false end
  end
  return true
end
```
同样，为了检查$$A$$是否包含于$$B$$，需对每个$$A$$中的元素$$a$$做最多$$|B|$$次比较，共$$|A||B|$$次，因此`subset`函数的最坏时间复杂度为$$O(|A||B|)$$。

请注意`inset`和`subset`实现上的区别，`inset`只需要判断存在性，因此只要找到一个满足条件的情况即可退出循环，而`subset`需要判断任意性，只要找到一个不满足条件的情况即可退出循环。

自然得到两个集合相等的判断。
```
equalset(A,B) = subset(A,B) && subset(B,A)
```
实际上，`equalset`对于每一个$$a \in A,b \in B$$做了两次重复的比较(为什么)。我们可以利用到两个集合的基数从而避免重复比较。在Julia中，集合的基数可以用`length`函数。
```
equalset(A,B) = length(A) == length(B) && subset(A,B)
```
不难分析得出，`equalset`的最坏时间复杂度也是$$O(|A||B|)$$。

`length`函数还有一个作用是可以很方便地判断一个集合是否为空集。
```
emptyset(A) = length(A) == 0
```

## 集合的运算

我们首先来实现交集运算，根据定义，交集是两个集合的公共元素所组成的集合。因此只需检查一个集合中的每个元素是否属于另一个集合，如果属于，则该元素应该放入交集中。
```
function setintersect(A,B)
  C = []
  for a in A inset(a,B) && push!(C,a) end
  return C
end
```
相似的，两个集合的差集只需检查一个集合中的每个元素是否属于另一个集合，如果不属于，则该元素放入差集中。
```
function setminus(A,B)
  C = []
  for a in A inset(a,B) || push!(C,a) end
  return C
end
```
在实现集合的并集时，我们要考虑到任何元素不可被重复加入到集合中。一种可取的做法是在加入另一个集合的元素时，如果为公共元素，则不添加至并集之中。
```
function setunion(A,B)
  C = B
  for a in A inset(a,B) || push!(C,a) end
  return C
end
```
三个函数的最坏时间复杂度均为$$O(|A||B|)$$。

## 集合的构造

在许多实际问题中，我们要从已知的集合中筛选出一部分满足某种性质$$P$$的元素。分离公理告诉我们了我们该如何选取这些元素。给定一个集合待筛选集合$$A$$，性质$$P$$通常由布尔函数给出，我们只需检查每个$$A$$中的元素是否满足$$P$$即可。
```
function setseparate(A,P)
  B = []
  for a in A P(a) && push!(B,a) end
  return B
end
```
有时，性质$$P$$并不需要通过函数给出，我们可以将$$P$$的性质内嵌到构造中。
```
function setseparate(A)
  B = []
  for a in A
    res = begin
            P(a)
          end
    res && push!(B,a)
  end
  return B
end
```

替代公理指出，我们能够从已有集合直接通过计算映射到所需要的集合。给定集合$$A$$和映射$$f$$，则$$f(A)$$可如此构造
```
function setreplace(A,f)
  B = []
  for a in A push!(B, f(a)) end
  return
end
```
如果$$f$$未直接给出，可以将其内嵌到构造中。
```
function setreplace(A)
  B = []
  for a in A
    b = begin
          f(a)
        end
    push!(B, b) end
  return
end
```

## 大集合的生成

有时，我们需要找出满足性质$$P$$的自然数的子集。显然，因为自然数是无穷的，我们无法在有限时间内检查所有的自然数。我们惟一能做的，是找到任意有限个(或$$N$$个)满足条件的自然数，如果满足条件的自然数是无穷多的话。如果满足条件的自然数是有限的，或者实在太大，那我们至少可以检查所有小于某个临界值$$M$$的自然数。这时，我们需要定义一个额外变量记录`n`当前已经找到的满足条件的自然数个数。
```
function find(P, N, M)
  A = []
  n = i = 0
  while (n < N && i < M)
    P(i) && (push!(A, i); n += 1)
    i += 1
  end
  return A
end
```

## 集合的其它表示方法

通常，对于自然数的子集，我们还可以用特征函数的方法表示集合。构造一个比特数组`B`，则第$$i$$个元素`B[i]`为`true`当且仅当$$i$$是$$A$$的元素。例如
```
julia> B = falses(8);  # 初始化最多包含8个元素的数组，设置为空集
julia> B[1] = B[2] = B[4] = B[7] = true;  # 添加元素1,2,4,7
julia> B  # A = {1,2,4,7}
8-element BitArray{1}:
  true
  true
 false
  true
 false
 false
  true
 false
```

如果我们希望表示一个集合$$A\subseteq X$$，注意到$$|𝓟(X)|=2^{|X|}$$，一个子集可以和$$[2^{|X|}]$$(即$$\{1,2,\ldots,2^{|X|}\}$$)中的某一自然数对应。考虑数$$b$$二进制表示，将第$$i$$位($$1⩽i⩽|X|$$)为1表示为第$$i$$个元素在子集$$A$$中，这种表示是一种一一对应（为什么）。
```
julia> b = 75 % UInt8;
julia> bits(n)  # A = {1,2,4,7} ⊆ [8] = X
"01001011"
```

## 练习

1. 假设集合$$A,B$$都是有序的，请重新实现`subset`函数，使得最坏时间复杂度为$$O(|A|+|B|)$$。
2. 给定映射$$f$$和性质$$P$$，请内嵌构造集合$$A=\{f(x)|x\in X\wedge P(x)\}$$。
3. 给定集合$$A,B$$，构造笛卡尔积$$A\times B$$，分析时间复杂度。
4. 定义两个集合$$A,B$$的**对称差**为$$A\Delta B=(A\cup B)\setminus (A\cap B)$$，请写程序实现构造并分析最坏时间复杂度。
5. 编写程序，找出所有边长为整数且小于$$L$$的直角三角形，要求时间复杂度为$$O(L^2)$$。
6. 一个集合$$A$$称为**无和集**当且仅当$$A$$中任意两个元素的和不在$$A$$中，请写程序判断给定集合$$A$$是否为无和集，分析时间复杂度。
7. 在古希腊，Eratosthenes发现了一种从自然数ℕ中寻找所有小于等于数$$n$$的素数的筛选算法。首先构造集合$$P=[n]\setminus\{1\}$$，然后令$$p=2$$，从集合$$P$$中移除所有除$$p$$外$$p$$的倍数，找到$$P$$中下一个未被移除的元素，设为$$p$$，重复移除操作直到不存在下一个$$p$$。请写程序实现该算法并分析时间复杂度。
8. 1934年，印度数学家Sundaram也发现了一种类似算法。首先构造集合$$P=\{k\inℕ\mid k\equiv1\mod 2\}$$，然后从集合$$P$$中找出子集$$Q=\{k\in P\mid \exists i,j\inℕ:k=i+j+2ij\}$$，则素数子集为$$P\setminus Q$$。请写程序实现该算法并分析时间复杂度，进一步，请证明该算法正确性。
9. 生成集合$$X$$的幂集并分析时间复杂度。（提示：对于每一个数$$b \in [2^{|X|}]$$，计算对应子集$$A\subseteq X$$）
10. 给定集合$$X$$,将其划分为两个子集，使得两个集合的基数相差不超过1。请写程序输出所有划分。