# Julia语言基础

计算机，作为一台物理机器，本质上只是一堆电子元件的集合。在接通电源以后，计算机根据电信号的输入，遵守物理定律，产生状态的变化，并产生电信号输出。为了使得输出与输入有一定的关联，或者说，让输出是为输入的某种人为定义的函数，我们需要设计具有完成某种功能能力的电路。幸运的是，现代计算机已经完成了对所有可计算函数的电路设计，人们只需要通过修改输入，计算机便可根据要求输出函数结果。不过，计算机终究没有足够的智慧理解人类的语言，我们依旧需要将我们的语言按照一定规范转换为计算机所能理解的语言。我们把这种转换称为**计算机编程**。

实际上，计算机所能理解的语言无非还是电信号，及一序列的高低电位，序列中的每一个电位叫做一个**比特**。我们通常用0和1分别表示低电位和高电位，因此可以认为，计算机所理解的语言，也称**机器语言**，就是01串，也叫**比特串**。为了便于人们编程，计算机先驱发明了许多不同的中间语言，称为**高级语言**。高级语言最大程度的贴近人们的语言习惯，使得人们可以方便的利用高级语言准确的表达所要解决的问题。然后，再通过已经设计好的**编译器**或**解释器**，将高级语言翻译为机器语言，最后通过计算机的计算产生问题结果。

本书推荐的Julia是2012年由MIT团队设计开发的一种高级语言。Julia的语法非常简单，对于初学者是一个非常友好和直接的与计算机对话的工具。接下来，我们将介绍一些Julia的基本语法。想要了解更多关于Julia的读者可以参考官方手册。

## 安装及使用

![](http://docs.julialang.org/en/release-0.5/_static/julia-logo.svg)

Julia可以通过官方网站([julialang.org](http://julialang.org/downloads/))直接下载安装即可，也可以通过注册登录([juliabox.com](https://www.juliabox.com/))直接在线使用。

实际上，任何一个文本编辑器都可以用于编程。为了提升效率和编程舒适度，我们推荐两个非常出色的编辑器，一个是[Atom](https://atom.io/)，一个是[Sublime](http://www.sublimetext.com/)。一些软件商甚至将代码、编译、调试和输出功能集成在一个编辑器中，称为**集成开发环境**，Julia官方推荐的集成开发环境为Juno([junolab.org](http://junolab.org/))。

双击Julia可执行文件或在命令行中输入```julia```即可进入Julia编程环境。输入```1+1```，然后回车，则julia即刻返回2。若要执行已经在文本编辑器中写完的程序，可以输入```include("文件名.jl")```，Julia程序默认的文件扩展名为.jl。输入```exit()```可以退出Julia编程环境。

若在Julia使用过程中想要查看某个函数的使用方法，可以首先输入```?```，再输入相应命令，即可获得使用帮助。也可以查看Julia的[使用文档](http://docs.julialang.org/)。我们还提供了一个[快速参考手册](https://trello.com/b/fppQ3unx/julia-manual)。

## 变量

### 定义

变量用于存储计算中的一些值，留作今后使用。例如，当我们在草稿纸上计算123×45时，首先计算123×5，再计算123×40，最后将两个量相加得到最后的乘积。为了在计算机中保存123×5和123×40的值，我们需要将它们放在两个变量当中，并且给予这两个变量**变量名**。

在Julia中，保存变量只要输入“变量名=变量值”即可，例如
```
julia> x = 123
123
julia> y = 45
45
julia> z = x*y
5535
```
当同时赋值多个变量时，还可以通过
```
julia> u = v = 123
123
julia> a, b = 5u, 40v
(615,4920)
julia> c = a+b
5535
```

注意，多数变量名应以字母开头，中间可以添加数字或下划线，并且应尽可能表达该变量的意义，如i,j常用于表示循环变量，total常用于统计总数，x1,x2常用于表示x的两个值。并且，变量名是大小写敏感的，Var和var会被认为是两个变量。另外，变量名也可以用大多数Unicode字符集表示，如"未知数","σ"。

### 数据类型

变量在计算机中同样是以比特串的形式存储的，我们可以通过```bits```函数查看变量的比特表示，如
```
julia> x, y = 2, 2.0
(2,2.0)
julia> bits(x)
"0000000000000000000000000000000000000000000000000000000000000010"
julia> bits(y)
"0100000000000000000000000000000000000000000000000000000000000000"
```
在64位的计算机中，CPU一个时钟周期可以处理的比特串长度为64位，因此一个数通常使用64比特表示。从上面的例子我们发现，虽然2和2.0在数学上是相等的，但在计算机中有不一样的表示，这是为什么？我们说计算机中没有小数点，也没有正负号，要表示小数或者负数同样需要用64个比特。于是，为了区分它们，必须指定变量类型。正如用手指表示“二”的时候，如果没有被正确解读，可能被误认为是“V”。

另一个可能出现的问题，如果一个数只用64个比特表示，那么岂不是最多只能表示2^64个数（为什么）。因此，我们必须要允许用更多的比特来表示更多的有效数字。变量类型的另一个作用便是指明表示变量所需的比特数。

在Julia中，变量类型可以被编译器隐式地做出推断。但有时为了提高程序运行效率，或表示更高的精度，我们可以显式指出变量类型。如
```
julia> x, y = Int16(2), Int128(2)
(2,2)
julia> bits(x)
"0000000000000010"
julia> bits(y)
"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010"
```

变量不仅可以表示数字，还可以表示如布尔值，字符或字符串。下面总结了Julia的一些常见的基本类型。

| 数据类型 | 具体类型 | 示例 |
| -- | -- | -- |
| 整型（整数）/无符号整型（非负） | Int, UInt | 1, -2, 3e4 |
| 大整数型 | BigInt | 10^BigInt(100) |
| 浮点型（小数） | Float | 1., -2.3, 4e-5 |
| 高精度浮点数 | BigFloat | BigFloat(1.2^34) |
| 有理数 | Fraction | 2//3 |
| 复数 | Complex | 1+2im |
| 布尔型 | Bool | true, false |
| 字符/字符串 | Char, String | 'x', "string" |

## 算子

算子，也称为运算符，正如我们接触过的加减乘除，是一种数到数的映射。或者，我们可以看作是一种以符号为名称的函数。例如
```
julia> 1+2+3, +(4,5,6)
(6,15)
julia> 1<=2, >(1,2)
(true,false)
```

算子根据操作数的个数，分为一元算子、二元算子、三元算子；根据在操作数中的位置，分为前缀算子、中缀算子和后缀算子。根据运算种类，还可以分为

### 算术算子

| 算子 | 说明 | 示例 |
| -- | -- | -- |
| ```+x``` | 恒等算子 | ```+1```返回```1``` |
| ```-x``` | 加法逆 | ```-1```返回```-1``` |
| ```+``` | 和 | ```2+3```返回```5``` |
| ```-``` | 差 | ```2-3```返回```-1``` |
| ```*``` | 积 | ```2*3```返回```6``` |
| ```/``` | 商 | ```3/2```返回```1.5``` |
| ```\``` | 逆商 | ```2\3```返回```1.5``` |
| ```%``` | 余数 | ```3%2```返回```1``` |
| ```^``` | 幂 | ```3^2```返回```9``` |

### 关系算子

| 算子 | 说明 | 示例 |
| ```--``` | -- | -- |
| ```==``` | 相等比较 | ```1==2```返回```false``` |
| ```!=``` | 不等比较 | ```1!=2```返回```true``` |
| ```>, >=``` | 大于, 大于或等于 | ```1>2, 1>=2, 2>=2>3```返回```false``` |
| ```<, <=``` | 小于, 小于或等于 | ```1<2, 1<=2, 2<=2<3```返回```true``` |

### 逻辑算子

| 算子 | 说明 | 示例 |
| -- | -- | -- |
| ```!``` | 逻辑非 | ```!true```返回```false``` |
| ```&&``` | 合取 | ```true&&false```返回```false``` |
| ```∣``` | 析取 | ```true∣∣false```返回```true``` |

注意，&&和||存在短路现象，即当前操作数可以确定结果时，则不计算后操作数。

### 位算子

位算子是将两个操作数的二进制逐比特进行运算返回结果。

| 算子 | 说明 | 示例 |
| -- | -- | -- |
| ```~``` | 位取反 | ```~2```返回```3``` |
| ```&``` | 位与 | ```2&3```返回```2``` |
| ```∣``` | 位或 | ```2∣3```返回```3``` |
| ```$``` | 异或 | ```2$3```返回```1``` |
| ```<<``` | 逻辑左移 | ```2<<1```返回```4``` | 
| ```<<<``` | 算数左移 | ```2<<<1```返回```4``` |
| ```>>``` | 逻辑/算数右移 | ```2>>1```返回```1``` |

### 赋值算子

| 算子 | 说明 | 示例 |
| -- | -- | -- |
| ```=``` | 赋值 | ```x=y```令x值为y |
| ```op=``` | 运算后赋值，op为算术或位算子 | ```x+=2```令x值增加2 |

另外，对于两个数组的逐分量运算，可以用.op，即.跟上一个相应算子，如
```
julia> x=[1,3,5];y=[6,4,2];
julia> x.*y
[6,12,10]
julia> x.>y
[true,true,false]
julia> x.-=y; x
[-5,-1,3]
```

当多个算子同时出现时，为了避免产生歧义，应按如下优先级依次进行计算：算数、位（先乘除，后加减）>关系>逻辑>赋值。

## 函数

在Julia中，函数不仅包括狭义上的数学函数，根据自变量返回因变量，还包括运算过程，即一系列计算的集合。

### 基本数学函数

| 函数 | 说明 | 示例 |
| -- | -- | -- |
| ```e, pi, im``` | 自然对数底，圆周率，虚单位 | ```e,pi,2im```返回```(e = 2.7182818284590...,π = 3.1415926535897...,0 + 2im)``` |
| ```round, floor, ceil``` | 四舍五入, 向下取整, 向上取整 | ```round(1.5), floor(1.5), ceil(1,5)```返回```(2.0,1.0,2.0)``` |
| ```div, rem, mod, mod1``` | 整除，余数 | ```div(5,2), rem(5,2), mod(4,2), mod1(4,2)```返回```(2,1,0,2)``` |
| ```abs, abs2, sign``` | 绝对值，绝对值平方，符号值 | ```abs(-2), abs(-2), sign(-2), sign(0), sign(2)```返回```(2,4,-1,0,1)```
| ```sqrt, exp, log, log10``` | 平方根，立方根，自然指数，自然对数/对数，底10对数 | ```sqrt(16), exp(1), log(e^3), log(3,81), log10(100)```返回```(4.0,2.718281828459045,3.0,4.0,2.0)``` |
| ```sin/sind/sinpi, cos/cosd/cospi, tan/tand``` | 三角函数 | ```sin(pi/2), cospi(1), tand(90)```返回```(1.0,-1.0,Inf)``` |

### 函数定义

通常，为了实现一些较为复杂且需要重复使用的功能，我们可以自定义函数。函数主要分为以下几个部分，函数名、函数参数、函数体和返回值。

#### 简单函数

简单函数通常实现较为简单的功能，定义也非常直接，如
```
julia> p(x)=2x^4-3x+1; p(2)
27
julia> dist(u,v)=sqrt(u^2+v^2); foo(3,4)
5.0
julia> mean(x,y)=((x+y)/2,sqrt(x*y)); mean(2,8)
(5.0,4.0)
```
注意，在一个语句末尾添加分号；可以抑制不必要的输出。有时，为了语法需要，可以用括号将多个语句括起来(;)作为一个语句，叫做**链语句**。例如
```
julia> S(a,b,c)=(p=(a+b+c)/2; sqrt(p*(p-a)*(p-b)*(p-c)); S(3,4,5)
6.0
```

#### 块函数

当一个函数有较多中间步骤时，常使用块函数。块函数以function关键字开头，end关键字结尾，通过return关键字返回函数值，并结束函数计算（即return之后的任何语句都将被忽略）。请看下例
```
julia> function line(x1,y1,x2,y2)
         k = (y2-y1)/(x2-x1)
         b = y1-k*x1
         f(x) = k*x+b
         return f
       end;
julia> l = line(1,2,2,3);
julia> l(1), l(2), l(3)
(2.0,3.0,4.0)
```
从上例我们发现，函数返回值不必要是数，还可以是函数。

#### 匿名函数

同样，函数的参数也可以不是数，而是函数。通常，为了避免不必要的定义，我们可以使用匿名函数。匿名函数用```->```定义，请看
```
julia> eval(f,x) = f(x);
julia> eval(x->x+1, 2), eval(x->x*x, 3)
(3,9)
julia> ((x,y)->x*y)(2,3)
6
```

### 函数参数

#### 可选参数

函数的可选参数常用于设定函数的默认表现，当该参数被设置时，函数按照该参数设置进行计算；若未被设置，则函数按默认设置进行计算。注意，可选参数必须放在非可选参数之后。请看下例
```
julia> linear(k,b=0,x=1) = k*x+b;
julia> linear(1,2,3), linear(1,2), linear(1)
(5,3,1)
```

#### 关键字参数

有时，一个函数可能含有多个参数，为了方便设置参数，可以给参数设置一个关键字，则调用时可以将该参数放置在非关键字参数后的任意位置。请看下例
```
julia> quadratic(a; axis=0, height=0) = x->a*(x-axis)^2+height;
julia> quadratic(1,height=3)(0), quadratic(2, height=0, axis=1)(2)
(3,2)
```

#### 变长参数

变长参数用于函数参数个数不确定，但不影响计算方法的函数。定义时在变长参数后面添加```...```，在传入列表参数时，也需在参数后面添加```...```。请看下例
```
julia> ktimes(k,xs...)=k*sum(xs);
julia> ktimes(2,1), ktimes(2,1,2,3)
(2,12)
julia> ktimes(2,[1,2,3]), ktimes(2,[1,2,3]...)
([2,4,6],12)
```

### 作用域

## 控制流

在命令式语言中，程序的基本执行结构有三类：顺序结构、条件结构和循环结构，分别对应顺序执行、选择执行和重复执行。

### 复合语句

顺序结构指逐条按照指令执行，顺序结构也是Julia的默认执行顺序。有时，可以将多条语句组合起来作为一条指令，称为**复合语句**。在上一节中我们见到的**链语句**便是复合语句的一种，链语句通常写在同一行中。若多条语句不在同一行，可使用**块语句**。块语句以begin开头，end结尾，返回end之前最后一个语句的值。例如
```
julia> a,b,c = 1,-3,2;
julia> x1, x2 = begin
                  D = b^2-4a*c
                  t = -b+sqrt(D)
                  2c/t, t/2a
                end
(1.0,2.0)
```

### 条件语句

条件语句根据条件的真假判断是否执行语句。在Julia中，条件语句有多种形式。

#### ```if-elseif-else```语句

```if-elseif-else``` 语句是最常见的条件语句，从第一个if开始判断，如果成立，则执行相应语句，之后整个if语句结束；若不成立则依次判断下一个elseif；如果所有if均不成立，则执行else相应语句；若不存在else语句，则不执行。

```
julia> x = 75;
julia> if x > 60 println("及格") end
及格
julia> if x >= 90
         println("优秀")
       else
         println("尚需努力")
       end
尚需努力
julia> if x >= 90
         println("优秀")
       elseif x >= 80
         println("良好")
       elseif x >= 60
         println("及格")
       else
         println("不及格")
       end 
及格
```

if语句还可以嵌套使用，请看下例
```
julia> x = 75;
julia> if x >= 60
         if x >= 80 println("[80,100]")
         else println("[60,80]")
         end
       else
         println("[0,60)")
       end
[60,80]
```

#### ```?:```语句

```?:``` 语句可以看作是```if-else```语句，请看例子
```
julia> eveness(x) = x%2 == 0 ? true : false;
julia> eveness(1), eveness(2)
false, true
```

#### ```ifelse```函数

```ifelse``` 函数区别于```if-else```语句，可看作分段函数，例如
```
julia> f(x) = ifelse(x >= 0, x, -x);
julia> f(1), f(-2)
(1,2)
```

#### &&和||

回忆之前提到，合取&&和析取||具有短路现象，即当且仅当第一个操作数不能确定结果时才计算第二个操作数。因此，&&相当于```if-then```，||则相当于```if not-then```。合取和析取的应用通常能简化代码，例如
```
julia> positive(x) = x>0 && true;
julia> nonnegative(x) = x<0 || false;
julia> negative(x) = x<0 && true || false;
julia> positive(1), nonnegative(1), negative(1)
(true,true,false)
```

### 循环语句

循环语句每次判断循环条件是否成立，若成立则执行循环体，否则退出循环。在Julia中有while和for两种循环。

#### while循环

```
julia> i = 1;
julia> while(i<=10)
         print(i)
         i += 1
       end
12345678910
```
特别需要注意，在while的循环体中一定要有改变循环条件状态的语句，否则程序将进入**死循环**，最终导致程序崩溃。

#### for循环

for循环常用于遍历一个容器或一个区间的所有元素，对每一个元素进行相应计算，然后退出循环。例如
```
julia> for x in [2,0,3,0,4]
         print(x+1)
       end
31415
```

通常，区间[s,e]或集合{s,s+t,s+2t,…,s+nt<=e}可表示为```s:e```(相应的```s:t:e```)，则可用for循环遍历区间如下
```
julia> for x = 1:2:10
          print(x+1)
        end
246810
```

在Julia中，for循环还可以遍历两个集合的笛卡尔积。
```
julia> for x=1:2, y=1:3
         println("$x×$y=$(x*y)")
       end
1×1=1
1×2=2
1×3=3
2×1=2
2×2=4
2×3=6
```

#### continue, break语句

在循环体当中，有时需要对某个状态进行特殊处理。这时我们可以嵌套if语句进行特例判断，使用continue语句可以使循环跳过当前状态进行下一次循环。例如
```
julia> set = [0,1,3];
julia> for x in set, y in set
         y == 0 && continue
         println("$x÷$y=$(x/y)")
       end
0÷1=0.0
0÷2=0.0
1÷1=1.0
1÷2=0.5
2÷1=2.0
2÷2=1.0
```

有时，退出循环的条件需要在循环中确定，于是我们需要使用break语句来终止循环。请看例子
```
julia> x = 5;
       while(true)
         abs(x-sqrt(2)) < 1e-5 && break
         println(x)
         x = x-(x^2-2)/2x
       end
5
2.7
1.7203703703703703
1.44145536817765
1.414470981367771
```

### 异常处理

## 数组

## 复合数据类型